// in eery question just think what you will do when you reach at the base conditon 
q1...
static long f(int n,long dp[]){
        if(n<=1){
            return n;
        }
        if(dp[n]!=-1)
            return dp[n];
        return dp[n]=(f(n-1,dp)+f(n-2,dp))%(long)(1e9+7);
    }
    static long topDown(int n) {
        // code here
        long dp[]=new long[n+1];
        Arrays.fill(dp,-1);
        return f(n,dp);
    }
    
    
    static long bottomUp(int n) {
        // code here
        long prev=1;
        long secPrev=0;
        for(int i=2;i<=n;i++){
            long curr=(prev+secPrev)%(long)(1e9+7);;
            secPrev=prev;
            prev=curr;
        }
        
        return prev;
    }



q2. 
class Solution {
    public int climbStairs(int n) {

        // when you reach at destination it means way possible 
        int zero=1;

        // when we are at first stair so only single jump can be performed
        int first=1;


        // i represent stair 

        for(int i=2;i<n+1;i++){
            // when we are at stair i 
            // left single jump 
            // right double jump
            int way= zero +first;
            zero = first;
            first = way;
        }

        return first;

        
    }
}

q3.
import java.util.* ;


import java.io.*; 
public class Solution {

    static int dp[];
    public static int frogJump(int n, int heights[]) {

        // you have n stairs 

        // Write your code here..
        dp=new int[n+1];
        Arrays.fill(dp,-1);


        return possibleJumps(n-1, heights);
    }


    public static int possibleJumps(int index,int heights[]){
        if(index==0){
            return 0;
        }

        if(dp[index]!=-1){
            return dp[index];
        }

        int left=possibleJumps(index-1, heights) + Math.abs(heights[index] - heights[index-1]);
        int right=Integer.MAX_VALUE;
        if(index>1){
             right=possibleJumps(index-2, heights)+ Math.abs(heights[index] - heights[index-2]);
        }

        return dp[index]=Math.min(left, right);
    }


}


q5. 
class Solution {
    int dp[];

    public int rob(int[] nums) {
        // memoization
        dp = new int[nums.length + 1];
        Arrays.fill(dp, -1);

        // length-1 because last element index
        return pickNonAdjacent(nums.length - 1, nums);

    }

    int pickNonAdjacent(int index, int[] nums) {
        if (index == 0) {
            // at index 0 we have only option to select it as it reaced here because 1 index
            // not selected
            return nums[0];
        }

        if (index < 0) {
            // never to be selceed so zero
            return 0;
        }

        if (dp[index] != -1) {
            // meoization picked
            return dp[index];
        }

        // pick element so sum will increase hence index-1 cant be selected
        int pick = nums[index] + pickNonAdjacent(index - 2, nums);

        // non pick elemetns no change hence index-1 can be selceted
        int nonPick = pickNonAdjacent(index - 1, nums);

        // we need max sum
        dp[index] = Math.max(pick, nonPick);

        return dp[index];
    }

}



q6.
class Solution {

    public int rob(int[] nums) {

        // if size == 1return that element
        if (nums.length == 1) {
            return nums[0];
        }

        // create two differenet dp
        // dp[index] gives f(index) means max sum possible till that index
        int dp1[] = new int[nums.length]; // for last included
        int dp2[] = new int[nums.length]; // for frist included

        Arrays.fill(dp1, -1);
        Arrays.fill(dp2, -1);

        int[] lastIncluded = Arrays.copyOfRange(nums, 1, nums.length);
        int[] firstIncluded = Arrays.copyOfRange(nums, 0, nums.length - 1);

        int max = Math.max(circularNonAdjacent(lastIncluded.length - 1, lastIncluded, dp1),
                circularNonAdjacent(firstIncluded.length - 1, firstIncluded, dp2));

        return max;

    }

    // similar function to robber 1
    int circularNonAdjacent(int index, int[] nums, int[] dp) {

        if (index == 0) {
            return nums[0];
        }
        if (index < 0) {
            return 0;
        }
        if (dp[index] != -1) {
            return dp[index];
        }

        // element picked
        int pick = nums[index] + circularNonAdjacent(index - 2, nums, dp);

        // element not picked
        int nonPick = circularNonAdjacent(index - 1, nums, dp);
        dp[index] = Math.max(pick, nonPick);
        return dp[index];

    }
}


q7.


tabulation : 
import java.util.Arrays;

public class Solution {
    public static int ninjaTraining(int n, int points[][]) {

        // Write your code here..
        int dp[][]=new int[n][4];
        for(int i=0;i<points.length;i++){
            Arrays.fill(dp[i], -1);
        }


        // dp[day][last] array consists of f(day,last) tells you the maxPoint earned on this day if day-1 task performed was last 
        // last can be 0 ,1 ,2 ,3
        //  0 wil be task 1
        // 1 will be task 2
        // 2 will be task 3
        //  3 will be no task 

        //  first day 
        // Initialize the first day's maximum points based on the available choices
        dp[0] [0]=Math.max(points[0][1], points[0][2]);
        dp[0] [1]=Math.max(points[0][0], points[0][2]);
        dp[0] [2]=Math.max(points[0][0], points[0][1]);
        dp[0] [3]=Math.max(points[0][0], Math.max(points[0][1], points[0][2]));

        
        // Iterate through each day and each activity basec on available choices
        for(int day=1;day<n;day++){
            for(int last=0;last<4;last++){
                // Initialize the maximum points for the current day and last activity
                // Consider each possible task for the current day
                dp[day][last]=0;
                // if day = 1 and you perform task 1 on day 0 option avail  task 0 and task 2
                 // if day = 1 and you perform task 2 on day 0 option avail  task 1 and task 0
                // if day = 1 and you perform task 0 on day 0 option avail  task 1 and task 2


                for(int task=0;task<3;task++){
                    // we atart selecting from the available choices 
                    // for day 1 last 1 you choose task 0
                    // dp[0][0] will give the max frofit as on day zero you can perform task 1 or otask 2 
                    // Ensure that the current task is different from the last
                    // Calculate the points for the current activity and add it to the maximum points from the previous day
                    if(task!=last){
                        int pts=points[day][task] + dp[day-1][task];
                         // Update the maximum points for the current day and last activity
                        dp[day][last]=Math.max(dp[day][last], pts);
                    }
                }
                
            }
        }


        return dp[n-1][3];


    }

}

memoization :

import java.util.Arrays;


public class Solution {
    static int dp[][];
    public static int ninjaTraining(int n, int points[][]) {
        // Write your code here..
        dp=new int [n][4];
        for(int i=0;i<n;i++){
            Arrays.fill(dp[i], -1);
        }


        return maxPoints(n-1,3,points);
    }


    static int maxPoints(int day,int last,int points[][]){

        
        if(day==0){
            int max=0;
            for(int i=0;i<3;i++){
                if(i!=last){
                    max=Math.max(points[0][i], max);
                }
            }
            dp[day][last]=max;

            return max;
        }

        if(dp[day][last]!=-1){
            return dp[day][last];
        }

        

        int max=0;
        for(int i=0;i<3;i++){
            if(i!=last){
                int pts=points[day][i] + maxPoints(day-1, i, points);
                max=Math.max(pts, max);
                dp[day][last]=max;
            }

        }

        return dp[day][last];
    }

}

q8. 
 
class Solution {

    // dp stores the dp[m][n] stores f(m,n) the max way from (m,n) to zero
    int dp[][];

    public int uniquePaths(int m, int n) {
        dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dp[i], -1);
        }

        // following array indexing
        return maxWay(m - 1, n - 1);

    }

    int maxWay(int row, int col) {

        // reach final destination return one way
        if (row == 0 && col == 0) {
            return 1;
        }

        // out of area so return 0 no way
        if (row < 0 || col < 0) {
            return 0;
        }

        // memoization
        if (dp[row][col] != -1) {
            return dp[row][col];
        }

        // top movement hence row -1
        int topM = maxWay(row - 1, col);
        // left movement hence col - 1
        int rightM = maxWay(row, col - 1);

        // imagine [0,0] and [1,1]
        // so topM gives one way
        // so leftM gives one way
        dp[row][col] = topM + rightM;
        // sum of both way
        return dp[row][col];

    }
}

q9. 
class Solution {
    // sane concept like previous question
    int dp[][];

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int row = obstacleGrid.length;
        int col = obstacleGrid[0].length;
        dp = new int[row][col];
        for (int i = 0; i < row; i++) {
            Arrays.fill(dp[i], -1);
        }

        return maxWay(row - 1, col - 1, obstacleGrid);

    }

    int maxWay(int row, int col, int[][] obstacleGrid) {
        // condtion wheather obstacle occured or not if occured cancel the way
        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1) {
            return 0;
        }

        if (row == 0 && col == 0) {
            return 1;
        }

        if (row < 0 || col < 0) {
            return 0;
        }

        if (dp[row][col] != -1) {
            return dp[row][col];
        }

        // up movement
        int topM = maxWay(row - 1, col, obstacleGrid);
        // left movement
        int leftM = maxWay(row, col - 1, obstacleGrid);
        dp[row][col] = topM + leftM;
        return dp[row][col];
    }
}


q10.
class Solution {

    // dp[row][col] contains the value of funct(row,col) means path value from (0,0)
    // to (row-1,col-1)
    int dp[][];

    public int minPathSum(int[][] grid) {

        // assigning the value to dp -1
        int row = grid.length;
        int col = grid[0].length;
        dp = new int[row][col];
        for (int i = 0; i < row; i++) {
            Arrays.fill(dp[i], -1);
        }

        return minPath(grid, row - 1, col - 1);

    }

    // return min path fron(row,col) to (0,0)
    int minPath(int[][] grid, int row, int col) {

        // reached final destination
        if (row == 0 && col == 0) {
            return grid[0][0];
        }

        // out of area so we return a larger number so that it become a long path
        if (row < 0 || col < 0) {
            return (int) 1e9;
        }

        // memoization
        if (dp[row][col] != -1) {
            return dp[row][col];
        }

        // up movement
        int up = grid[row][col] + minPath(grid, row - 1, col);
        // left movement
        int left = grid[row][col] + minPath(grid, row, col - 1);

        // assigning min path value
        dp[row][col] = Math.min(up, left);

        // return min path value
        return dp[row][col];

    }
}


q11.
class Solution {
    // basically dp contains the value of funct(row,col) means min cost (0,0) to
    // (row-1,col-1)
    int dp[][];

    public int minimumTotal(List<List<Integer>> triangle) {
        int row = triangle.size();
        dp = new int[row][row];

        for (int i = 0; i < row; i++) {
            Arrays.fill(dp[i], -1);
        }

        // start from (0,0)
        return minPath(triangle, 0, 0);

    }

    // return the min cost from (0,0) to (row,col)
    // used bottom down approach
    // prevois question we use top down approach
    int minPath(List<List<Integer>> triangle, int row, int col) {

        // we reach our destination when we reach on last row and at any col
        // we will never go out of the bound
        if (row == triangle.size() - 1) {
            return triangle.get(row).get(col);
        }

        // memoization
        if (dp[row][col] != -1) {
            return dp[row][col];
        }

        // bottom movement
        int bottom = triangle.get(row).get(col) + minPath(triangle, row + 1, col);

        // diagonal movement
        int diagonal = triangle.get(row).get(col) + minPath(triangle, row + 1, col + 1);

        // required min cost path
        dp[row][col] = Math.min(bottom, diagonal);

        return dp[row][col];
    }
}


q12. 
class Solution {

    // dp contains funct(row,col) which have the min path value from (n-1,[0,n-1])
    // to (0,[0,n-1])
    int dp[][];

    public int minFallingPathSum(int[][] matrix) {
        int row = matrix.length;

        dp = new int[row][row];

        for (int i = 0; i < row; i++) {
            // asign Integer.MIN_VALUE as values are negative
            Arrays.fill(dp[i], Integer.MIN_VALUE);
        }

        int min = Integer.MAX_VALUE;

        // checking the all min vpath for each index of row 0 and then take min from
        // there
        for (int i = 0; i < row; ++i) {
            min = Math.min(min, minPath(matrix, row - 1, i));

        }

        return min;

    }

    // return min path from (row,col) to (0,[0-matrix.length])
    int minPath(int[][] matrix, int row, int col) {

        // out of bond case so make that path value maximum
        if (col < 0 || col >= matrix.length) {
            return (int) 1e9;
        }

        // reached destination
        if (row == 0) {
            return matrix[row][col];
        }

        // memoization
        if (dp[row][col] != Integer.MIN_VALUE) {
            return dp[row][col];
        }

        // bottom movement
        int bottom = matrix[row][col] + minPath(matrix, row - 1, col);
        // diagonal left movement
        int dgLeft = matrix[row][col] + minPath(matrix, row - 1, col - 1);
        // digonal right movement
        int dgRight = matrix[row][col] + minPath(matrix, row - 1, col + 1);

        // return the min path value
        dp[row][col] = Math.min(bottom, Math.min(dgLeft, dgRight));
        return dp[row][col];

    }
}



q13. 
class Solution {
    

    // create an 3d array 
    // dp[row][robA][robB] stores the value  of f(row,robA,robB) gives you the max berry can be collectoed from current position
    int[][][] dp;

    public int cherryPickup(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;

        dp = new int[row][col][col];
        
        // assign 3d arrays with -1
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                Arrays.fill(dp[i][j], -1);

            }
        }
        

        // at every step f(row,robA,robB) gives you the max berry can be collectoed from current position
        return collectBerry(grid, 0, 0, col - 1);

    }
    // row current row of both robot
    // robA current clm of robot a 
    // robB current clm of robot b
    // row always be same because we start from zero row and every step we increament row
    // retrun the max berry collected from both robots 
    // move both robot simultaneosly
    int collectBerry(int[][] matrix, int row, int robA, int robB) {

        // out of bound case give negative large neagtive number so it never get selected
        if (robA < 0 || robB < 0 || robA >= matrix[0].length || robB >= matrix[0].length) {
            return (int) -1e8;
        }
        
        // reacehd at the final row of the matrix means destination
        if (row == matrix.length - 1) {
            // both robot on same block so count 1
            if (robA == robB) {
                return matrix[row][robB];

            }

            // imagine yourself  on n-1 row and then max berry can be collected by both robots
            return matrix[row][robA] + matrix[row][robB];
        }
        

        // memoization
        if (dp[row][robA][robB] != -1) {
            return dp[row][robA][robB];
        }
        
        // stores the current value
        int current = 0;
        // basically at particular postion we can have 9 ways both robot can move 
        // so out of 9 we need max 
        int max = Integer.MIN_VALUE;


        for (int i = -1; i < 2; i++) {
            for (int j = -1; j < 2; j++) {
                if (robA == robB) {
                    current = matrix[row][robA] + collectBerry(matrix, row + 1, robA + i, robB + j);

                } else {
                    current = matrix[row][robA] + matrix[row][robB] + collectBerry(matrix, row + 1, robA + i, robB + j);

                }
                max = Math.max(max, current);

            }
        }
        

        // return the max from this state 
        return dp[row][robA][robB]=max;
    }
}



q14. 
import java.util.* ;


public class Solution {
    
    // dp arrays to stores the answer f(index,target) contains the wheather there is subset exhist with target sum till index in arr
    static int dp[][];
    public static boolean subsetSumToK(int n, int k, int arr[]){
        // Write your code here.
        // there are n number in so there are n number only 
        // for target we can assume the target can vary fom 0 - target so need to store  target  as well
        dp=new int[n][k+1];

        for(int i=0;i<n;i++){
            Arrays.fill(dp[i], -1);
        }

        // -1 not run for this value
        // 0 false
        // 1 true

        if(solutionExhist(n-1, k, arr)==1){
            return true;
        }

        return false;
    }


    public static int solutionExhist(int index,int target,int arr[]){
        // if target zero empty subsequence 
        if(target==0){
            return 1;
        }
        
        // index ==0 means single element which is etiher eqaul to  the target 
        if(index==0){
            if (arr[index]==target) {
                return 1;
                
            }
            return 0;
        }

        

        // memeoization
        if(dp[index][target]!=-1){
            return dp[index][target];
        }

        // not take this index element 
        int notTake=solutionExhist(index-1, target, arr);
        //  to take this element
        int take=0;
        // if the current element greater more than target then subsequence will definately make larger sum
        if(arr[index]<=target){
            // for left array we need subsequence which can make target - arr[index]
            take=solutionExhist(index-1, target-arr[index], arr);
        }
        
        dp[index][target]=0;

        // we need to  proof subsequence exhist 
        if(take==1 || notTake==1){
            dp[index][target]=1;
        }

        return dp[index][target];

    }
}



q15.
class Solution {
    // used to store the value of f(index,target) which gives the weather sum == target tile index in array
    int dp[][];

    public boolean canPartition(int[] nums) {
        
        // calculate sum
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        
        // if sum is not even then you cant divide odd sum into two equals part
        if (sum % 2 != 0) {
            return false;

        }
        // memoization we have store the value n index and also the target value act as an index 
        dp = new int[nums.length][sum + 1];
        for (int i = 0; i < nums.length; i++) {
            Arrays.fill(dp[i], -1);
        }

        partition(nums, nums.length-1, sum/2);
        
        // if the full array can make half sum then we can divide into two equal partition
        return dp[nums.length-1][sum/2]==1;

    }
    // funct(index,target) returns the wheather the target can be achieved from element till index in array
    int partition(int[] nums, int index, int target) {
        // if target is zero then you can make empty subset 
        if (target == 0) {
            return 1;
        }
        

        // if index is zero then only one element left that means nums[0] only element can achieve target
        if (index == 0) {
            // target achieved
            if (target == nums[0]) {
                return 1;
            }
            return 0;
        }
        
        // memeoization
        if (dp[index][target] != -1) {
            return dp[index][target];
        }
        
        // not taking current index element
        int notTake = partition(nums, index - 1, target);
        // taking current index element 
        int take = 0;
        // if current index element  is greater than the target how can can we achieve target as greater become more greater
        if (target >= nums[index]) {
            take = partition(nums, index - 1,target - nums[index]);
        }

        // memoization

        dp[index][target] = 0;

        if (take == 1 || notTake == 1) {
            dp[index][target] = 1;

        }

        return dp[index][target];
    }
}



q16. longest common subsequence 
class Solution {
    // dp stores the function(indx1,indx2) which returns the the length of a common subsequence till indx1 for str1 and indx2 for str2
    int dp[][];

    public int longestCommonSubsequence(String text1, String text2) {
        // memoization 
        dp = new int[text1.length()][text2.length()];
        for (int i = 0; i < dp.length; i++) {
            Arrays.fill(dp[i], -1);

        }
        return lcs(text1, text1.length() - 1, text2, text2.length() - 1);

    }
    // returns the lcs till indx1 in string a and indx2 in string b
    public int lcs(String txt1, int indx1, String txt2, int indx2) {
        // any index is out of bound means no common subsequence 
        if (indx1 < 0 || indx2 < 0) {
            return 0;
        }
        
        // memoization
        if (dp[indx1][indx2] != -1) {
            return dp[indx1][indx2];
        }
        
        // character at this index are same hence are part of length of common subsequence 
        // decreament both index index for next lcs element 
        if (txt1.charAt(indx1) == txt2.charAt(indx2)) {
            return dp[indx1][indx2] = 1 + lcs(txt1, indx1 - 1, txt2, indx2 - 1);
        }
        
        // no character matches hence we have two option either we decrement indx1 or indx2
        // chances that current character may occur common in other string 
        return dp[indx1][indx2] = 0 + Math.max(lcs(txt1, indx1, txt2, indx2 - 1), lcs(txt1, indx1 - 1, txt2, indx2));

    }
}


q17. longest pallindrome subsequence 
class Solution {
    // memoization
    // stores the value of palLcs(s1,s2,indx1,indx2) which returns the max length of
    // lcs till indx1 in s1 and indx2 in s2
    int dp[][];

    public int longestPalindromeSubseq(String s) {
        int len = s.length();

        dp = new int[len][len];
        for (int i = 0; i < len; i++) {
            Arrays.fill(dp[i], -1);
        }
        // reverse a string
        String s2 = "";
        for (int i = len - 1; i >= 0; i--) {
            s2 = s2 + s.charAt(i);

        }
        // loigc is we have to find pallindrome
        // so s2=s1.reverse()
        // now we find the max lcs in s1 and s2 which will be the longest pallindrome
        return palLcs(s, s2, len - 1, len - 1);

    }

    // this function return the lcs in s1 till indx1 and in s2 till indx2
    public int palLcs(String s1, String s2, int indx1, int indx2) {
        // no lcs poosible
        if (indx1 < 0 || indx2 < 0) {
            return 0;
        }
        // memoization
        if (dp[indx1][indx2] != -1) {
            return dp[indx1][indx2];
        }
        // current characters are the part of subsequence
        if (s1.charAt(indx1) == s2.charAt(indx2)) {
            return dp[indx1][indx2] = 1 + palLcs(s1, s2, indx1 - 1, indx2 - 1);
        }
        // make out possible movements
        return dp[indx1][indx2] = 0 + Math.max(palLcs(s1, s2, indx1 - 1, indx2), palLcs(s1, s2, indx1, indx2 - 1));

    }
}

q18. min insertion to make string pallindrome 
class Solution {
    // dp stores the value of palCom(String s1,String s2,int indx1,int indx2) which
    // return the length of lcs in s1 till index1 and in s2 till index2
    int dp[][];

    public int minInsertions(String s) {
        // memoization
        int len = s.length();
        dp = new int[len][len];
        for (int i = 0; i < len; i++) {
            Arrays.fill(dp[i], -1);
        }
        // so we have concept to find the longest pallindrome subsequence
        // so just imagine in main string the longest pallindrome is balanced so we need
        // to only balance the elemnts which are not pallindrome
        String s2 = "";
        for (int i = len - 1; i >= 0; i--) {
            s2 += s.charAt(i);
        }

        return len - palCom(s, s2, len - 1, len - 1);

    }

    // value of palCom(String s1,String s2,int indx1,int indx2) which return the
    // length of lcs in s1 till index1 and in s2 till index2
    public int palCom(String s1, String s2, int indx1, int indx2) {
        if (indx1 < 0 || indx2 < 0) {
            return 0;
        }

        if (dp[indx1][indx2] != -1) {
            return dp[indx1][indx2];
        }

        if (s1.charAt(indx1) == s2.charAt(indx2)) {
            return dp[indx1][indx2] = 1 + palCom(s1, s2, indx1 - 1, indx2 - 1);
        }

        return dp[indx1][indx2] = 0 + Math.max(palCom(s1, s2, indx1, indx2 - 1), palCom(s1, s2, indx1 - 1, indx2));
    }
}


q19.minimum deletion to make string equal
class Solution {
    // meomoization
    // dp stores stores the value of longestLcs()
    int dp[][];
    public int minDistance(String word1, String word2) {
        int len1=word1.length();
        int len2=word2.length();
        dp=new int[len1][len2];
        // memoization
        for(int i=0;i<len1;i++){
            Arrays.fill(dp[i],-1);
        }
        // eliminate the non element to make both string same 
        // one delete counts one operations 
        // len1- longestLcs() + len2-longestLcs()
        return len1+len2 - 2*longestLcs(word1,word2,len1-1,len2-1);   
    }
    
    // this function(s1,s2,indx1,indx2) return the longest lcs in s1 till indx1 and in s2 till indx2
    public int longestLcs(String s1,String s2,int indx1,int indx2){
        // no lcs possible
        if(indx1<0 || indx2<0){
            return 0;
        }
        // memoization
        if(dp[indx1][indx2]!=-1){
            return dp[indx1][indx2];
        }
        // current character are part of subsequence 
        if(s1.charAt(indx1) == s2.charAt(indx2)){
            return dp[indx1][indx2]=1+longestLcs(s1,s2,indx1-1,indx2-1);
        }

        // perform all possible soultions 
        return dp[indx1][indx2]=0+Math.max(longestLcs(s1,s2,indx1,indx2-1),longestLcs(s1,s2,indx1-1,indx2));
    }
}



q20. shortest supersequence 
class Solution {
    // used memoziation 
    // in this question we are using 1 based indexing
    // dp contains the f(s1,i1,s2,i2) value which means length of lcs in s1 till not (include) i1 in s1 and in s2 till i2
    int dp[][];
    public String shortestCommonSupersequence(String str1, String str2) {
        
        int len1=str1.length();
        int len2=str2.length();
        // last case would be complete array 
        dp=new int[len1+1][len2+1];

        for(int i=0;i<len1+1;i++){
            Arrays.fill(dp[i],-1);
        }
        
        // filling out the dp array
        int lenCommon=lcs(str1,len1,str2,len2);
        String answer="";
        int i=len1; // for accessing string 1 
        int j=len2; // for accessing string 2 
        // string will acces through i-1 and j-1 
        // once we move left then current colmun cant be access
        // col represent particular character in s2 
        // once we move up then current row cant be access so that s1 character we need to add 
        // row represent particular character in s1
        while(i>0 && j>0){
            // diagonal move 
            if(str1.charAt(i-1)==str2.charAt(j-1)){
                answer=str1.charAt(i-1)+answer;
                i--;
                j--;
            }else if(dp[i-1][j] > dp[i][j-1] ){
                // up  movement means s1 elements is getting left so need to include him
                answer=str1.charAt(i-1) + answer;
                i--;
            }else{
                // left movement measn s2 elements is getting left so need to include him
                answer=str2.charAt(j-1) + answer;
                j--;
            }
        }
        // additional code apart from lcs printing 
        /// if i>0 means s1 have some left elements 
        while(i>0){
            answer=str1.charAt(i-1) + answer;
            i--;

        }
        // if j>0 means 2 have some left elemetns 
        while(j>0){
            answer=str2.charAt(j-1) + answer;
            j--;
            
        }
        return answer;
        
    }
    // this function return the len of lcs till indx1 in str1 and indx2 inx2 in str2
    // string is access by index-1
    public int lcs(String str1,int indx1,String str2,int indx2){
        if(indx1==0 || indx2==0){
            return 0;
        }

        if(dp[indx1][indx2]!=-1){
            return dp[indx1][indx2];
        }

        if(str1.charAt(indx1-1) == str2.charAt(indx2-1)){
            return dp[indx1][indx2]  = 1+lcs(str1,indx1-1,str2,indx2-1);

        }

        return dp[indx1][indx2] = 0+Math.max(lcs(str1,indx1-1,str2,indx2),lcs(str1,indx1,str2,indx2-1));
    }
}


q21. edit distance 
class Solution {
    // memoization 
    // it contains the value of the minOpr(s1,i1,s2,i2) means min operation required to make s1==s2 till (indx1,indx2)(including)
    int dp[][];
    public int minDistance(String word1, String word2) {
        int len1=word1.length();
        int len2=word2.length();
        dp=new int[len1][len2];
        for(int i=0;i<len1;i++){
            Arrays.fill(dp[i],-1);
        }
        return minOpr(word1,len1-1,word2,len2-1);
        
    }
    // min operation required to make s1==s2 till (indx1,indx2)(including)
    // assume word1 > word2
    public int minOpr(String word1,int indx1,String word2,int indx2){
        // base case
        //means word1 is over hence need to add insert all left elemtns of word2
        if(indx1<0){
            return indx2+1;
        }
        // means word2 is over hence need to delete all left eleemnts of word1
        if(indx2<0){
            return indx1+1;
        }
        // memoization
        if(dp[indx1][indx2]!=-1){
            return dp[indx1][indx2];
        }
        // condition
        // character mataches hence no opr required move to another element 
        if(word1.charAt(indx1)==word2.charAt(indx2)){
            return dp[indx1][indx2]=0+minOpr(word1,indx1-1,word2,indx2-1);
        }
        
        // perform all possible solutions 
        // insert theoritcally we add elem after current elem hence current char in word2 match with the inserted element 
        int insert=1+minOpr(word1,indx1,word2,indx2-1);
        // delete theoritcally deleted we delete elem in word1 but there is no match 
        int delete=1+minOpr(word1,indx1-1,word2,indx2);

        // replace hence both the current character satisfied 
        int replace=1+minOpr(word1,indx1-1,word2,indx2-1);
        // return min
        return dp[indx1][indx2]=Math.min(insert,Math.min(delete,replace));
    }
}


q22. max profit on stock sell and buy 2
class Solution {
    // use memoization to store the maxprofit we can get dp[currentDay][canBuy] from the currentDay to the zero days left 
    int dp[][];
    public int maxProfit(int[] prices) {
        // memoization
        int totalDay=prices.length;
        dp=new int[totalDay][2];
        for(int i=0;i<totalDay;i++){
            Arrays.fill(dp[i],-1);
        }
        // at day 0 you can buy the stock 
        // canBuy = 1 yes you can buy
        // canBuy = 0 no you cant buy 
        return maximaProfit(prices,totalDay,0,1);
        
    }
    
    // this fucntion return the max profit can be attained on the condition of canBuy from the current day to the zero day left
    // for sign remember profit = sell - buy ;
    public int maximaProfit(int [] prices,int totalDay,int currentDay,int canBuy){
        // means all days are gone last day also gone 
        // you cant buy stock on that day 
        // you cant sell stock if you have buy the stock
        // hence profit gets zero
        if(currentDay==totalDay){
            return 0;
        }
        // memoization
        if(dp[currentDay][canBuy]!=-1){
            return dp[currentDay][canBuy];
        }
        int profit=0;
        // eligible for buying
        if(canBuy==1){
            // you buyed stock on this day
            int buy=-prices[currentDay] + maximaProfit(prices,totalDay,currentDay+1,0);
            // you dont buyed stock on this day
            int notBuy=0+maximaProfit(prices,totalDay,currentDay+1,1);
            profit=Math.max(buy,notBuy);
        }else{
            // means you have buyed stock before 
            // sell the stock on this day
            int sell= prices[currentDay] + maximaProfit(prices,totalDay,currentDay+1,1);
            // dont sell the stock on this day
            int notSell=0+maximaProfit(prices,totalDay,currentDay+1,0);
            profit=Math.max(sell,notSell);

        }

        // return max profit
        return dp[currentDay][canBuy] = profit;
    }
}


q23. best time to sell and buy stock 3 atmost two transactions
class Solution {
    // dp stores the max profit from current day to the zero day left under the condts of canBuy and transleft
    int dp[][][];
    public int maxProfit(int[] prices) {
        // memoization
        int totalDay=prices.length;
        dp=new int[totalDay][2][3];
        for(int i=0;i<totalDay;i++){
            for(int j=0;j<2;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        // on day zero we can buy the stock and total transcations left would be 2
        
        return maximalProfit(prices,totalDay,0,1,2);
        
    }
    // return the max profit can be achieved from currentDay to the zero day left under condtions canBuy and transleft
    public int maximalProfit(int [] prices,int totalDay,int currentDay,int canBuy,int transLeft){
        // if no transcations can be performed hence we can buy more stocks 
        // no day left so you can either buy stock or sell the buyed stock
        if(transLeft ==0 || currentDay == totalDay){
            return 0;
        }
        // memoization
        if(dp[currentDay][canBuy][transLeft]!=-1)
        {
            return dp[currentDay][canBuy][transLeft];
        }

        int profit=0;
        if(canBuy==1){
            // eligible for buying
            // buy the stock
            int buy=-prices[currentDay] + maximalProfit(prices,totalDay,currentDay+1,0,transLeft);
            // not buy the stock
            int nbuy=0+maximalProfit(prices,totalDay,currentDay+1,1,transLeft);
            profit=Math.max(buy,nbuy);
        }else{
            // sell the stock 
            // you can sell the stock then only transcation complted 
            // stock sold
            int sell = prices[currentDay] + maximalProfit(prices,totalDay,currentDay+1,1,transLeft-1);
            // not sold the stock
            int nsell = 0 + maximalProfit(prices,totalDay,currentDay+1,0,transLeft);
            profit=Math.max(sell,nsell);
        }
        
        // return max profit
        return dp[currentDay][canBuy][transLeft] =  profit;
    }
}


q24. best time to buy and sell stock 4 with atmost trans k
class Solution {
    // stores the max profit can be acheived from the currentDay to the zero day left under conitions canBuy and transLeft
    int dp[][][];
    public int maxProfit(int k, int[] prices) {
        int totalDay=prices.length;
        dp=new int[totalDay][2][k+1];
        for(int i=0;i<totalDay;i++){
            for(int j=0;j<2;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        // on day-0 you can buy and transLeft would be equal to k
        return maximalProfit(prices,totalDay,0,1,k);
        
    }
    // returns  the max profit can be acheived from the currentDay to the zero day left under conitions canBuy and transLeft
    public int maximalProfit(int [] prices,int totalDay,int currentDay,int canBuy,int transLeft){
        // max trans capability have achived so you cant niether buy or sell
        // if zero day left then you cant perform either buy or sell
        if(transLeft==0 || currentDay==totalDay){
            return 0;
        }
        // memoization
        if(dp[currentDay][canBuy][transLeft]!=-1){
            return dp[currentDay][canBuy][transLeft];
        }
        
        int profit=0;

        if(canBuy==1){
            // eligible for buying
            // buyed
            int buy=-prices[currentDay] + maximalProfit(prices,totalDay,currentDay+1,0,transLeft);
            // not buyed
            int nbuy=0+maximalProfit(prices,totalDay,currentDay+1,1,transLeft);
            profit=Math.max(buy,nbuy);

        }else{
            // not eligible for buying
            // sold
            int sell=prices[currentDay] + maximalProfit(prices,totalDay,currentDay+1,1,transLeft-1);
            // not sold
            int nsell=0+maximalProfit(prices,totalDay,currentDay+1,0,transLeft);
            profit=Math.max(sell,nsell);
        }

        // returns the max profit
        return dp[currentDay][canBuy][transLeft] = profit;
    }
}



q25. best time to buy and sold stock with cooldown
class Solution {
    // same concept as best time to buy and sell stock
    // just different with cooldown
    // stores the max profit possible from currentDay to the zero day left under
    // conditons canBuy
    int dp[][];

    public int maxProfit(int[] prices) {
        int totalDay = prices.length;
        dp = new int[totalDay][2];
        for (int i = 0; i < totalDay; i++) {
            Arrays.fill(dp[i], -1);
        }

        return maximalProfit(prices, totalDay, 0, 1);
    }

    // returns the max profit possible from currentDay to the zero day left under
    // conditons canBuy
    public int maximalProfit(int prices[], int totalDay, int currentDay, int canBuy) {
        // possible you sold the stock on the last day
        if (currentDay >= totalDay) {
            return 0;
        }
        // memoization
        if (dp[currentDay][canBuy] != -1) {
            return dp[currentDay][canBuy];
        }

        int profit = 0;

        // eligible for buying
        if (canBuy == 1) {
            // buy
            int buy = -prices[currentDay] + maximalProfit(prices, totalDay, currentDay + 1, 0);
            // not buy
            int nbuy = 0 + maximalProfit(prices, totalDay, currentDay + 1, 1);
            profit = Math.max(buy, nbuy);

        } else {
            // selling on currentDay hence you cant buy on currentDay+1 so move to
            // currentDay+2
            // sold
            int sell = prices[currentDay] + maximalProfit(prices, totalDay, currentDay + 2, 1);
            // not sold
            int nsell = 0 + maximalProfit(prices, totalDay, currentDay + 1, 0);
            profit = Math.max(sell, nsell);
        }
        // returns the max profit
        return dp[currentDay][canBuy] = profit;
    }
}


q26. best time  to buy and sold the stock with transcation fee
class Solution {
    // stores the max profit from the currentday to zero day left after deduction
    // fee under the condiions canBuy
    int dp[][];

    public int maxProfit(int[] prices, int fee) {
        int totalDay = prices.length;
        dp = new int[totalDay][2];
        for (int i = 0; i < totalDay; i++) {
            Arrays.fill(dp[i], -1);
        }

        return maximalProfit(prices, totalDay, fee, 0, 1);

    }

    // returns the max profit from the currentday to zero day left after deduction
    // fee under the condiions canBuy
    public int maximalProfit(int[] prices, int totalDay, int fee, int currentDay, int canBuy) {
        // no day left you cant sell or buy
        if (currentDay == totalDay) {
            return 0;
        }
        // memoiuzation
        if (dp[currentDay][canBuy] != -1) {
            return dp[currentDay][canBuy];
        }

        int profit = 0;
        // eligible for buying
        // fess will be deducted on the time of sell stock
        if (canBuy == 1) {
            // buyed
            int buy = -prices[currentDay] + maximalProfit(prices, totalDay, fee, currentDay + 1, 0);
            // not buy
            int nbuy = 0 + maximalProfit(prices, totalDay, fee, currentDay + 1, 1);
            profit = Math.max(buy, nbuy);
        } else {
            // sold
            // fees deducted
            int sell = -fee + prices[currentDay] + maximalProfit(prices, totalDay, fee, currentDay + 1, 1);
            // not sold
            int nsell = maximalProfit(prices, totalDay, fee, currentDay + 1, 0);
            profit = Math.max(sell, nsell);
        }
        // return max profit
        return dp[currentDay][canBuy] = profit;
    }
}




q27. count the number of subset that make the sum equal to the target
import java.util.*;
import java.io.*;

public class Solution {
    // memoization to store the value of func(index,num,targ) which return the number of way to make targ from zero till(including) index
    public static int[][] dp;
    public static int findWays(int num[], int tar) {
        // Write your code here.
        dp=new int[num.length][tar+1];
        for(int i=0;i<num.length;i++){
            Arrays.fill(dp[i],-1);
        }

        return findWay(num.length-1,num,tar);
    }
    
    //func(index,num,targ) which return the number of way to make targ from zero till(including) index
    public static int findWay(int index,int num[],int targ){
        // target is zero
        if(targ==0){
            // coutning number of zero from current to zero
            // case included no zero selected 
            double way=0;
            for(int i=index;i>=0;i--){
                if(num[index]==0){
                    way++;

                }
            }
            way=Math.pow(2, way);
            return (int)(way);
        }
        // array end reached
        if(index==0){
            if(num[0]==targ){
                return 1;
            }
            return 0;
        }
        
        // memoization
        if(dp[index][targ]!=-1){
            return dp[index][targ];
        }
        // current index not picked
        int notPick=findWay(index-1, num, targ);
        // current index picked
        int pick=0;
        // check weather current index element is not greater than target
        if(num[index]<=targ){
            pick=findWay(index-1, num, targ-num[index]);
        }
        dp[index][targ]=pick+notPick;
        return dp[index][targ];
    }
}


q28.Longest increasing subsequence 
class Solution {
    // stores the value of funct(current,prev) which return the length of incresing subsequence from current to end under condition last element picked was previous 
    int dp[][];
    public int lengthOfLIS(int[] nums) {
        int len=nums.length;
        // as intitiall prev_index selected would be -1 so we will stores the value of func(curr,prev) in dp[curr][prev+1]
        dp=new int[len][len+1];
        for(int i=0;i<len;i++){
            Arrays.fill(dp[i],-1);
        }
        
        // return the max increasing sequence undder the condition no index selected and current index is zero
        return maxLength(nums,0,-1);
        
        
    }
    // funct(current,prev) which return the length of incresing subsequence from current to end under condition last element picked was previous 
    public int  maxLength(int []nums,int current_index,int prev_index){
        // out of elements
        if(current_index==nums.length){
            return 0;
        } 
        // memoization
        if(dp[current_index][prev_index+1]!=-1){
            return dp[current_index][prev_index+1];
        }
        // current index not picked
        int nonPick = 0+maxLength(nums,current_index+1,prev_index);
        int pick=0;
        // checking wheather the current index can be picked 
        if(prev_index==-1 || nums[current_index] > nums[prev_index]){
            pick=1+maxLength(nums,current_index+1,current_index);
        }
        // return the max of(possible solution)
        return dp[current_index][prev_index+1] = Math.max(pick,nonPick);
    }
}


q29. printing longest subsequence 
class Solution {
    public ArrayList<Integer> longestIncreasingSubsequence(int n, int arr[]) {
        // Code here
        // hash[index] gives the index of the last element of the sequence 
        int hash[]=new int[n];
        // stores the longest sequence possible from index zero to current idex
        int dp[]=new int[n];
        // fill with 1 as element makes it self a sequence 
        Arrays.fill(dp,1);
        // length of longest subsequence 
        int max=1;
        // last element index of longest sequence 
        int last_index=0;
        for(int current=0;current<n;current++){
            // element it self a sequnce 
            hash[current]=current;
            // check from the prevous index to form longest sequnce 
            for(int prev=0;prev<current;prev++){
                // we got the longest sequnce than prev seq hence need to change dp[current]
                if(arr[current] > arr[prev] && dp[current] < dp[prev] + 1){
                    dp[current]=dp[prev] + 1;
                    // change is due to the arr[prev]
                    hash[current] = prev;
                }
                
            }
            // update in longest sequnce 
            if(dp[current] > max){
                max=dp[current];
                last_index=current;
            }
        }
        
        // back track 
        ArrayList<Integer> answer=new ArrayList<Integer>();
        answer.add(arr[last_index]);
        
        while(hash[last_index] != last_index){
            last_index=hash[last_index];
            answer.add(arr[last_index]);
        }
        Collections.reverse(answer);
        return answer;
        
    }
}


q30.Longest divisble subsequence 
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        // sorting nunber to assure that the if current element is divisble by the the last element of possible subsequence then all pairs are divsisble 
        Arrays.sort(nums);
        int len=nums.length;
        // stores the lenghth of largest subsequence from 0 to till that index
        int dp[]=new int[len];
        // assuming that the possible slution can be the element it self 
        Arrays.fill(dp,1);
        // to keep the backtrack as hash[index] stores the element of the last possible subsequence 
        int hash[]=new int[len];
        // case for the only one element in sequence 
        int maxLen=1;
        int last_index=0;
        
        // judiing for the current index
        for(int current=0;current < len;current++){
            // pointing to itself only 
            hash[current]=current;
            // checking out all possible subsequence before the current index 
            // as nums[prev] will act the last element of the subsequence so ut divides then all pair would be divisible 
            for(int prev=0;prev<current;prev++){
                // condition check 
            
                if(nums[current]%nums[prev] ==0 && dp[current] < dp[prev]+1){
                    // need to stores the prev index in hash as to print our all squance 
                    dp[current]=dp[prev]+1;
                    hash[current]= prev;
                }

            }
            // max length os subset changes hence last index 0f the index also get altered 
            if(maxLen < dp[current]){
                maxLen=dp[current];
                last_index=current;
            }
        }

        // backtraking through hash 
        // last_index return the index of the last element of the subsequence 
        // hash[last_index] gives the last index of the subset which part of final answer
        // hash[index]
        List<Integer> ans=new ArrayList<Integer>();
        ans.add(nums[last_index]);
        // just watch video 
        while(hash[last_index]!=last_index){
            last_index=hash[last_index];
            ans.add(nums[last_index]);
        }

        return ans;

        
    }
}

q31. Longest String chain
class Solution {

    // check the weather this both string can make a chain or not
    public boolean checkString(String a, String b) {
        // a.length > b.length
        // their length differnce should be 1
        if (a.length() != b.length() + 1) {
            return false;
        }

        int first = 0;
        int second = 0;

        while (first < a.length()) {
            // character matches
            if (second < b.length() && a.charAt(first) == b.charAt(second)) {
                first++;
                second++;

            } else {
                // character dont match
                first++;
            }
        }
        // visualize through notes
        if (first == a.length() && second == b.length()) {
            return true;
        }

        return false;
    }

    public int longestStrChain(String[] words) {
        // rememebr we need subset so no need to order to maintain
        // sorting the words basaed on the ther length
        Comparator<String> compAlph = new Comparator<String>() {
            public int compare(String a, String b) {
                return a.length() - b.length();
            }
        };

        Arrays.sort(words, compAlph);
        System.out.println(words[0]);
        // dp stores the max length of subsequence till that index
        int[] dp = new int[words.length];
        Arrays.fill(dp, 1);
        int maxLen = 1;

        for (int current = 0; current < words.length; current++) {
            // try out all the possible combination for the current element 
            for (int prev = 0; prev < current; prev++) {
                // prev deontes the last index of max  subsequence  till prev if last element of subsequence can
                // make string chain than whole sequnce can make
                if (checkString(words[current], words[prev]) && dp[current] < dp[prev] + 1) {
                    // dp[current] value changes
                    dp[current] = dp[prev] + 1;
                }
            }
            maxLen = Math.max(maxLen, dp[current]);
        }

        return maxLen;

    }
}


q32.Number of longest subsequnce 
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int len = nums.length;
        // dp[i] store the maxlen of subsequence till index index i
        int[] dp = new int[len];
        // count[i] the number of possible subsequnce of len dp[i]
        int[] count = new int[len];
        // 1 dignify the sequence of element it self
        Arrays.fill(dp, 1);
        Arrays.fill(count, 1);
        // max length of possible subsequence
        int maxLen = 1;

        // till this index = current checking the possible sequnces
        for (int curr = 0; curr < len; curr++) {
            // try out weather this element can be part of the previous sequnces
            for (int prev = 0; prev < curr; prev++) {
                // current element can part of the sequence of prev
                if (nums[prev] < nums[curr]) {
                    // if same length sequnce found add alll the possible way to make sequnce prev
                    if (dp[curr] == dp[prev] + 1) {
                        count[curr] += count[prev];
                        // if we got new max len for current then all possible way to make sequnce till
                        // current would be same as to make sequnce till prev
                    } else if (dp[curr] < dp[prev] + 1) {
                        dp[curr] = dp[prev] + 1;
                        count[curr] = count[prev];
                    }
                }
            }
            // max length
            maxLen = Math.max(maxLen, dp[curr]);
        }
        // finding out the number of sequnce of length = maxLength
        int finalAnswer = 0;

        for (int i = 0; i < len; i++) {
            if (dp[i] == maxLen) {
                finalAnswer += count[i];
            }
        }
        ;

        return finalAnswer;

    }
}


q33. assign cookies
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        // g refers to the children greed array
        // s refers to the cookie_size array
        // allot min cookie first  to those whose greed is less 
        Arrays.sort(g);
        Arrays.sort(s);
        // denotes the which cookie is getting allloted
        int cookie_num=0;
        // denotes which children greed is getting satisfied
        int child_num=0;

        while(cookie_num < s.length && child_num < g.length){
            // you can only satisfy the children greed when greed<=cookie_size
            if(g[child_num] <= s[cookie_num]){
                // child satisfied
                child_num++;
            }
            // no matter if cookie is alloted then you cant allot to other 
            // if cookie is not alloted because of unsatisfaction then it cant be alloted to anyone greed is in sorted manner
            cookie_num++;
        }

        /// try to have dry run 
        return child_num;
        
    }
}




q34.Coin change 
class Solution {
    // memoization stores the value of minCoins(index,coins,target) which returns
    // the minCoins to achieve that target till index
    int dp[][];

    public int coinChange(int[] coins, int amount) {
        int len = coins.length;
        // memoization
        dp = new int[len][amount + 1];

        for (int i = 0; i < len; i++) {
            Arrays.fill(dp[i], -1);
        }
        // returning the minCoins to achieve amount till len-1 index
        int answer = minCoins(len - 1, coins, amount);
        // handling out the non possible scene
        return answer >= 1e9 ? -1 : answer;

    }
    // minCoins(index,coins,target) which returns
    // the minCoins to achieve that target till index
    public int minCoins(int index, int[] coins, int target) {
        // target is zero hence coin addition is there
        if (target == 0) {
            return 0;
        }
        // reached at the last coin
        if (index == 0) {
            // checking wheather whoule target can be achieved through the last coin or not
            if (target % coins[index] == 0) {
                // give the number of coins (last) used to make that target
                return target / coins[index];
            }
            // solution dont exhist
            return (int) 1e9;
        }
        // memoization
        if (dp[index][target] != -1) {
            return dp[index][target];
        }
        // current index coins not picked
        int notPick = 0 + minCoins(index - 1, coins, target);
        int pick = Integer.MAX_VALUE;
        // check weather the current coin can be picked id coins[index] > target then we
        // will exceed target
        if (coins[index] <= target) {
            // coin picked but we can again pick that particualr coin
            pick = 1 + minCoins(index, coins, target - coins[index]);
        }
        // return ths min coins solution
        return dp[index][target] = Math.min(notPick, pick);
    }
}



q35. number of subset with the differnece d 
import java.util.* ;
import java.io.*; 

public class Solution {
    public static int[][] dp;
	// ensures that number does not overflow
    public static int mod =(int)1e9 + 7;

    
	// this function return the number of subset possible till index under condiotion target
    public static int countNumber(int[] arr, int index, int target) {
        if (target == 0) {
            // Counting the number of zeros from the current index down to 0
            int numberOfZero = 0;
            for (int i = index; i >= 0; i--) {
                if (arr[i] == 0) {
                    numberOfZero++;
                }
            }
			// adding all possible out solutions
            return (int)Math.pow(2, numberOfZero);  // 2^numberOfZero
        }
        
		// reached at the last index 
        if (index == 0) {
            if (arr[index] == target) {
                return 1;
            }
            return 0;
        }
        // memoization
        if (dp[index][target] != -1) {
            return dp[index][target];
        }
        
		// non pick
        int nonPick = countNumber(arr, index - 1, target);
        int pick = 0;
        if (arr[index] <= target) {
			// pick
            pick = countNumber(arr, index - 1, target - arr[index]);
        }
        
        return dp[index][target] = (nonPick + pick) % mod;
    }

    public static int countPartitions(int n, int d, int[] arr) {
        int totalSum = 0;
        for (int i = 0; i < n; i++) {
            totalSum += arr[i];
        }

        // If totalSum - d is negative or not divisible by 2, partition is impossible look at formula 
        if (totalSum - d < 0 || (totalSum - d) % 2 != 0) {
            return 0;
        }

        int target = (totalSum - d) / 2;
        dp = new int[n][target + 1];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], -1);
        }

        return countNumber(arr, n - 1, target);
    }
}


q36.Target sum
class Solution {
    // exactly the same concept applied to the dp - 18 problem
    // stores dp[index][target] the number of subset that can form target till index
    public int dp[][];

    // the number of subset that can form target till index
    public int countSubset(int[] nums, int index, int target) {
        // coutning number of of zero from current index
        if (target == 0) {
            int numZero = 0;

            for (int i = index; i >= 0; i--) {
                if (nums[i] == 0) {
                    numZero++;
                }
            }
            int possibleSoln = (int) Math.pow(2, numZero);
            return possibleSoln;
        }
        // reached at last index
        if (index == 0) {
            if (nums[index] == target) {
                return 1;
            }
            return 0;
        }
        // memoization
        if (dp[index][target] != -1) {
            return dp[index][target];
        }
        // not picked
        int nonPick = countSubset(nums, index - 1, target);
        // picked
        int pick = 0;
        if (nums[index] <= target) {
            pick = countSubset(nums, index - 1, target - nums[index]);
        }
        return dp[index][target] = pick + nonPick;
    }

    public int findTargetSumWays(int[] nums, int target) {
        // same concept applied in dp -18 problem
        int totalSum = 0;
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            totalSum += nums[i];
        }
        int sum = totalSum - target;
        if (sum < 0 || (sum % 2) != 0) {
            return 0;
        }

        dp = new int[len][(sum / 2) + 1];
        for (int i = 0; i < len; i++) {
            Arrays.fill(dp[i], -1);
        }

        return countSubset(nums, len - 1, sum / 2);

    }
}


q37. number of possible ways to make the amount Coin change - II
class Solution {
    // stores the value of funct(index,target) which returns number of way to achieve target amount till index 
    public int dp[][];

    // funct(index,target) which returns number of way to achieve target amount till index
    public int  uniqueWay(int coins[],int index,int target){
        // amount achieved 
        if(target==0){
            // hence return 1 signify one way signify 
            return 1;
        }
        
        // reached at the last index as only the possibe solution 
        if(index==0){
            // paying all the amount by this last coins value 
            return target%coins[index]==0 ? 1 : 0;
        }
        
        // memoization
        if(dp[index][target] !=-1){
            return dp[index][target];
        }
        // current coin not be picked
        int notPick=uniqueWay(coins,index-1,target);
        
        int pick=0;
        // cehckin weather the current coin dont exceed the target
        if(coins[index]<=target){
            // picked the current coin but not altering index as it can be picked once again
            pick=uniqueWay(coins,index,target-coins[index]);
        }
        // sum of all possible solution
        return dp[index][target]=notPick+pick;
    }
    public int change(int amount, int[] coins) {
        // memoization
        int len=coins.length;
        dp=new int[len][amount+1];
        for(int i=0;i<len;i++){
            Arrays.fill(dp[i],-1);
        }
        // returns the number of way to complete the amount till index len-1 
        return uniqueWay(coins,len-1,amount);
        
    }
}
